import { Deferred } from '../../deferred';
import { GitlabDiscussions } from './gitlab-api/discussions-api';
import { CommitApprovals } from './commit-approvals';

export namespace CommentParser {
    import Promise = JQuery.Promise;
    const sectionBreak = '---\n';

    const generatedHeader = `***GENERATED BY GITLAB PLUGIN, DO NOT MODIFY BY HAND***\n${sectionBreak}`;
    function isGeneratedMessage(body: string) {
        return (body || '').startsWith(generatedHeader);
    }

    const commitApprovalHeader = '**My commit approvals:**\n';
    function getApprovedCommitIdsFromMessage(body: string) {
        if (!isGeneratedMessage(body)) {
            return [];
        }

        const messageParts = body.split(sectionBreak) || [];
        const commitMessagePart = messageParts.find(messagePart =>
            (messagePart || '').startsWith(commitApprovalHeader),
        );

        if (!commitMessagePart) {
            return [];
        }

        const lines = commitMessagePart.split('\n');
        lines.shift();
        lines.pop();
        return lines.map(line => (line || '').replace(/\s*\*\s*/g, '')).filter(Boolean);
    }

    function parseMessage(body: string) {
        if (!isGeneratedMessage(body)) {
            return null;
        }

        return {
            approvedCommits: getApprovedCommitIdsFromMessage(body),
        };
    }

    function generateMessage(approvedCommitIds?: string[]) {
        let result = generatedHeader;

        if (approvedCommitIds && approvedCommitIds.length > 0) {
            result += commitApprovalHeader;
            (approvedCommitIds || []).forEach(id => {
                result += `*  ${id}\n`;
            });
            result += sectionBreak;
        }

        return result;
    }

    export interface MergeRequestCommentData {
        approvals: CommitApprovals.Approvals;
        yourNoteId: number | null;
        yourDiscussionId: string | null;
    }

    export function saveMergeRequestCommentData(mergeRequestId: number | undefined) {
        if (!mergeRequestId) {
            return Promise.resolve();
        }

        if (!window.monar_MR_DATA) {
            return Promise.reject('toggleCommitApproval: no monar_MR_DATA');
        }

        const approvals = window.monar_MR_DATA.approvals || {};
        const yourApprovals = Object.keys(approvals).filter(id => {
            const apps = approvals[id] || [];
            return apps.some(app => app.username === window.monar_GLOBALS.username);
        });
        const message = generateMessage(yourApprovals);

        if (window.monar_MR_DATA.yourNoteId && window.monar_MR_DATA.yourDiscussionId) {
            return GitlabDiscussions.modifyMergeRequestNote(
                mergeRequestId,
                window.monar_MR_DATA.yourDiscussionId,
                window.monar_MR_DATA.yourNoteId,
                message,
            ).then(() => {});
        } else {
            return GitlabDiscussions.createMergeRequestThread(mergeRequestId, message).then(thread =>
                GitlabDiscussions.resolveMergeRequestThread(mergeRequestId, thread.id, true).then(() => {}),
            );
        }
    }

    export function fetchMergeRequestCommentData(mergeRequestId: number | undefined) {
        if (!mergeRequestId) {
            return Promise.resolve((undefined as any) as MergeRequestCommentData);
        }

        const result = new Deferred<MergeRequestCommentData>();
        const object: MergeRequestCommentData = {
            approvals: {},
            yourNoteId: null,
            yourDiscussionId: null,
        };

        GitlabDiscussions.getMergeRequestDiscussions(mergeRequestId).then(discussions => {
            (discussions || []).forEach(discussion => {
                (discussion.notes || []).forEach(note => {
                    const parsedNote = parseMessage(note.body);
                    if (parsedNote) {
                        if (note.author && note.author.username === window.monar_GLOBALS.username) {
                            object.yourNoteId = note.id;
                            object.yourDiscussionId = discussion.id;
                        }
                        (parsedNote.approvedCommits || []).forEach(id => {
                            object.approvals[id] = object.approvals[id] || [];
                            object.approvals[id].push({
                                username: note.author.username,
                                avatar: note.author.avatar_url,
                                name: note.author.name,
                            });
                        });
                    }
                });
            });
            window.monar_MR_DATA = object;
            result.resolve(object);
        });

        return result.promise;
    }
}
