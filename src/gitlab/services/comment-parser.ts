import { Deferred } from '../classes/deferred';
import { GitlabDiscussions } from './gitlab-api/discussions-api';
import { CommitApprovals } from './commit-approvals';

export namespace CommentParser {
    import Promise = JQuery.Promise;
    const sectionBreak = '---\n';

    const generatedHeader = `***GENERATED BY GITLAB PLUGIN, DO NOT MODIFY BY HAND***\n${sectionBreak}`;
    function isGeneratedMessage(body: string) {
        return (body || '').startsWith(generatedHeader);
    }

    const commitApprovalHeader = '**My commit approvals:**\n';
    function getApprovedCommitIdsFromMessage(body: string) {
        if (!isGeneratedMessage(body)) {
            return [];
        }

        const messageParts = body.split(sectionBreak) || [];
        const commitMessagePart = messageParts.find(messagePart =>
            (messagePart || '').startsWith(commitApprovalHeader),
        );

        if (!commitMessagePart) {
            return [];
        }

        const lines = commitMessagePart.split('\n');
        lines.shift();
        lines.pop();
        return lines.map(line => (line || '').replace(/\s*\*\s*/g, '')).filter(Boolean);
    }

    function parseMessage(body: string) {
        if (!isGeneratedMessage(body)) {
            return null;
        }

        return {
            approvedCommits: getApprovedCommitIdsFromMessage(body),
        };
    }

    function generateMessage(approvedCommitIds?: string[]) {
        let result = generatedHeader;

        if (approvedCommitIds && approvedCommitIds.length > 0) {
            result += commitApprovalHeader;
            (approvedCommitIds || []).forEach(id => {
                result += `*  ${id}\n`;
            });
            result += sectionBreak;
        }

        return result;
    }

    export interface MergeRequestCommentData {
        approvals: CommitApprovals.Approvals;
        noteId: number | null;
    }

    export function saveMergeRequestCommentData(mergeRequestId: number | undefined) {
        if (!mergeRequestId) {
            return Promise.resolve();
        }

        const approvals = window.monar_MR_DATA?.approvals || {};
        const yourApprovals = Object.keys(approvals).filter(id => {
            const apps = approvals[id] || [];
            return apps.some(app => app.username === window.monar_GLOBALS.username);
        });
        const message = generateMessage(yourApprovals);
        console.log(message);
        // TODO

        return Promise.resolve();
    }

    export function fetchMergeRequestCommentData(mergeRequestId: number | undefined) {
        if (!mergeRequestId) {
            return Promise.resolve((undefined as any) as MergeRequestCommentData);
        }

        const result = new Deferred<MergeRequestCommentData>();
        const object: MergeRequestCommentData = {
            approvals: {},
            noteId: null // TODO
        };

        GitlabDiscussions.getMergeRequestDiscussions(mergeRequestId).then(discussions => {
            (discussions || []).forEach(discussion => {
                (discussion.notes || []).forEach(note => {
                    const parsedNote = parseMessage(note.body);
                    if (parsedNote) {
                        (parsedNote.approvedCommits || []).forEach(id => {
                            object.approvals[id] = object.approvals[id] || [];
                            object.approvals[id].push({
                                username: note.author.username,
                                avatar: note.author.avatar_url,
                                name: note.author.name,
                            });
                        });
                    }
                });
            });
            window.monar_MR_DATA = object;
            result.resolve(object);
        });

        return result.promise;
    }
}
